// Generated by github.com/kr/genbolt. DO NOT EDIT.
// See schema/schema.go.

package db

import bytes "bytes"
import encoding "encoding"
import binary "encoding/binary"
import json "encoding/json"
import bolt "github.com/coreos/bbolt"
import fsm "github.com/interstellar/starlight/starlight/fsm"
import update "github.com/interstellar/starlight/starlight/internal/update"

const _ = binary.MaxVarintLen16
const _ = bolt.MaxKeySize
const _ = bytes.MinRead

// Root is a bucket with a static set of elements.
//
// Root is the type of the root bucket, as required by genbolt.
//
// Accessor methods read and write records
// and open child buckets.
// See functions View and
// Update to open transactions.
type Root struct {
	db *bolt.Tx
}

// NewRoot returns a new Root for tx.
//
// Root is the type of the root bucket, as required by genbolt.
func NewRoot(tx *bolt.Tx) *Root {
	return &Root{tx}
}

// View opens a read-only transaction
// and calls f with an instance of Root as the root bucket.
// It returns the error returned by f.
func View(db *bolt.DB, f func(*Root) error) error {
	return db.View(func(tx *bolt.Tx) error {
		return f(&Root{tx})
	})
}

// Update opens a writable transaction
// and calls f with an instance of Root as the root bucket,
// then it commits the transaction.
// It returns the error returned by f,
// or any error committing to the database, if f was successful.
func Update(db *bolt.DB, f func(*Root) error) error {
	return db.Update(func(tx *bolt.Tx) error {
		return f(&Root{tx})
	})
}

// Tx returns o's underlying *bolt.Tx object.
// This can be useful to access low-level database functions
// or other features not exposed by this generated code.
func (o *Root) Tx() *bolt.Tx {
	return o.db
}

// Agent is a bucket with a static set of elements.
//
// Agent is the db layout for a Starlight agent.
//
// Accessor methods read and write records
// and open child buckets.
type Agent struct {
	db *bolt.Bucket
}

// Bucket returns o's underlying *bolt.Bucket object.
// This can be useful to access low-level database functions
// or other features not exposed by this generated code.
//
// Note, if o's transaction is read-only and the underlying
// bucket has not previously been created in a writable
// transaction, Bucket returns nil.
func (o *Agent) Bucket() *bolt.Bucket {
	return o.db
}

// Config is a bucket with a static set of elements.
//
// Config is the db layout for Starlight agent-level configuration.
//
// Accessor methods read and write records
// and open child buckets.
type Config struct {
	db *bolt.Bucket
}

// Bucket returns o's underlying *bolt.Bucket object.
// This can be useful to access low-level database functions
// or other features not exposed by this generated code.
//
// Note, if o's transaction is read-only and the underlying
// bucket has not previously been created in a writable
// transaction, Bucket returns nil.
func (o *Config) Bucket() *bolt.Bucket {
	return o.db
}

// Agent gets the child bucket with key "Agent" from o.
//
// Agent creates a new bucket if none exists
// and o's transaction is writable.
// Regardless, it always returns a non-nil *Agent;
// if the bucket doesn't exist
// and o's transaction is read-only, the returned value
// represents an empty bucket.
func (o *Root) Agent() *Agent {
	return &Agent{bucket(o.db, keyAgent)}
}

// Config gets the child bucket with key "Config" from o.
//
// Config creates a new bucket if none exists
// and o's transaction is writable.
// Regardless, it always returns a non-nil *Config;
// if the bucket doesn't exist
// and o's transaction is read-only, the returned value
// represents an empty bucket.
func (o *Agent) Config() *Config {
	return &Config{bucket(o.db, keyConfig)}
}

// Updates gets the child bucket with key "Updates" from o.
//
// Updates creates a new bucket if none exists
// and o's transaction is writable.
// Regardless, it always returns a non-nil *SeqOfUpdateUpdate;
// if the bucket doesn't exist
// and o's transaction is read-only, the returned value
// represents an empty bucket.
func (o *Agent) Updates() *SeqOfUpdateUpdate {
	return &SeqOfUpdateUpdate{bucket(o.db, keyUpdates)}
}

// Channels gets the child bucket with key "Channels" from o.
//
// Channels holds the state of all open channels. Closed channels
// are deleted. (Their history is still available in Updates.)
//
// Channels creates a new bucket if none exists
// and o's transaction is writable.
// Regardless, it always returns a non-nil *MapOfFsmChannel;
// if the bucket doesn't exist
// and o's transaction is read-only, the returned value
// represents an empty bucket.
func (o *Agent) Channels() *MapOfFsmChannel {
	return &MapOfFsmChannel{bucket(o.db, keyChannels)}
}

// Ready reads the record stored under key "Ready".
//
// Ready indicates whether or not the Agent is ready to accept
// and process new commands. The Agent is only in a not-ready
// state when it is closing.
//
// If no record has been stored, Ready returns
// the zero value.
func (o *Agent) Ready() bool {
	rec := get(o.db, keyReady)
	return len(rec) > 0 && rec[0] != 0
}

// PutReady stores v as a record under the key "Ready".
//
// Ready indicates whether or not the Agent is ready to accept
// and process new commands. The Agent is only in a not-ready
// state when it is closing.
func (o *Agent) PutReady(v bool) {
	rec := make([]byte, 1)
	if v {
		rec[0] = 1
	}
	put(o.db, keyReady, rec)
}

// EncryptedSeed reads the record stored under key "EncryptedSeed".
// If no record has been stored, EncryptedSeed returns
// the zero value.
func (o *Agent) EncryptedSeed() []byte {
	rec := get(o.db, keyEncryptedSeed)
	v := make([]byte, len(rec))
	copy(v, rec)
	return v
}

// PutEncryptedSeed stores v as a record under the key "EncryptedSeed".
func (o *Agent) PutEncryptedSeed(v []byte) {
	rec := v
	put(o.db, keyEncryptedSeed, rec)
}

// NextKeypathIndex reads the record stored under key "NextKeypathIndex".
// If no record has been stored, NextKeypathIndex returns
// the zero value.
func (o *Agent) NextKeypathIndex() uint32 {
	rec := get(o.db, keyNextKeypathIndex)
	if rec == nil {
		return 0
	}
	return binary.BigEndian.Uint32(rec)
}

// PutNextKeypathIndex stores v as a record under the key "NextKeypathIndex".
func (o *Agent) PutNextKeypathIndex(v uint32) {
	rec := make([]byte, 4)
	binary.BigEndian.PutUint32(rec, v)
	put(o.db, keyNextKeypathIndex, rec)
}

// PrimaryAcct reads the record stored under key "PrimaryAcct".
// If no record has been stored, PrimaryAcct returns
// a pointer to
// the zero value.
func (o *Agent) PrimaryAcct() *fsm.AccountID {
	rec := get(o.db, keyPrimaryAcct)
	v := new(fsm.AccountID)
	if rec == nil {
		return v
	}
	err := encoding.BinaryUnmarshaler(v).UnmarshalBinary(rec)
	if err != nil {
		panic(err)
	}
	return v
}

// PutPrimaryAcct stores v as a record under the key "PrimaryAcct".
func (o *Agent) PutPrimaryAcct(v *fsm.AccountID) {
	rec, err := encoding.BinaryMarshaler(v).MarshalBinary()
	if err != nil {
		panic(err)
	}
	put(o.db, keyPrimaryAcct, rec)
}

// Wallet reads the record stored under key "Wallet".
// If no record has been stored, Wallet returns
// a pointer to
// the zero value.
func (o *Agent) Wallet() *fsm.WalletAcct {
	rec := get(o.db, keyWallet)
	v := new(fsm.WalletAcct)
	if rec == nil {
		return v
	}
	err := json.Unmarshal(rec, json.Unmarshaler(v))
	if err != nil {
		panic(err)
	}
	return v
}

// PutWallet stores v as a record under the key "Wallet".
func (o *Agent) PutWallet(v *fsm.WalletAcct) {
	rec, err := json.Marshal(json.Marshaler(v))
	if err != nil {
		panic(err)
	}
	put(o.db, keyWallet, rec)
}

// HorizonURL reads the record stored under key "HorizonURL".
// If no record has been stored, HorizonURL returns
// the zero value.
func (o *Config) HorizonURL() string {
	rec := get(o.db, keyHorizonURL)
	return string(rec)
}

// PutHorizonURL stores v as a record under the key "HorizonURL".
func (o *Config) PutHorizonURL(v string) {
	rec := []byte(v)
	put(o.db, keyHorizonURL, rec)
}

// Username reads the record stored under key "Username".
// If no record has been stored, Username returns
// the zero value.
func (o *Config) Username() string {
	rec := get(o.db, keyUsername)
	return string(rec)
}

// PutUsername stores v as a record under the key "Username".
func (o *Config) PutUsername(v string) {
	rec := []byte(v)
	put(o.db, keyUsername, rec)
}

// PwType reads the record stored under key "PwType".
//
// PwType records which hashing function was used for PwHash.
// Currently, it's always "bcrypt".
//
// If no record has been stored, PwType returns
// the zero value.
func (o *Config) PwType() string {
	rec := get(o.db, keyPwType)
	return string(rec)
}

// PutPwType stores v as a record under the key "PwType".
//
// PwType records which hashing function was used for PwHash.
// Currently, it's always "bcrypt".
func (o *Config) PutPwType(v string) {
	rec := []byte(v)
	put(o.db, keyPwType, rec)
}

// PwHash reads the record stored under key "PwHash".
// If no record has been stored, PwHash returns
// the zero value.
func (o *Config) PwHash() []byte {
	rec := get(o.db, keyPwHash)
	v := make([]byte, len(rec))
	copy(v, rec)
	return v
}

// PutPwHash stores v as a record under the key "PwHash".
func (o *Config) PutPwHash(v []byte) {
	rec := v
	put(o.db, keyPwHash, rec)
}

// MaxRoundDurMin reads the record stored under key "MaxRoundDurMin".
// If no record has been stored, MaxRoundDurMin returns
// the zero value.
func (o *Config) MaxRoundDurMin() int64 {
	rec := get(o.db, keyMaxRoundDurMin)
	if rec == nil {
		return 0
	}
	return int64(binary.BigEndian.Uint64(rec))
}

// PutMaxRoundDurMin stores v as a record under the key "MaxRoundDurMin".
func (o *Config) PutMaxRoundDurMin(v int64) {
	rec := make([]byte, 8)
	binary.BigEndian.PutUint64(rec, uint64(v))
	put(o.db, keyMaxRoundDurMin, rec)
}

// FinalityDelayMin reads the record stored under key "FinalityDelayMin".
// If no record has been stored, FinalityDelayMin returns
// the zero value.
func (o *Config) FinalityDelayMin() int64 {
	rec := get(o.db, keyFinalityDelayMin)
	if rec == nil {
		return 0
	}
	return int64(binary.BigEndian.Uint64(rec))
}

// PutFinalityDelayMin stores v as a record under the key "FinalityDelayMin".
func (o *Config) PutFinalityDelayMin(v int64) {
	rec := make([]byte, 8)
	binary.BigEndian.PutUint64(rec, uint64(v))
	put(o.db, keyFinalityDelayMin, rec)
}

// ChannelFeerate reads the record stored under key "ChannelFeerate".
// If no record has been stored, ChannelFeerate returns
// the zero value.
func (o *Config) ChannelFeerate() int64 {
	rec := get(o.db, keyChannelFeerate)
	if rec == nil {
		return 0
	}
	return int64(binary.BigEndian.Uint64(rec))
}

// PutChannelFeerate stores v as a record under the key "ChannelFeerate".
func (o *Config) PutChannelFeerate(v int64) {
	rec := make([]byte, 8)
	binary.BigEndian.PutUint64(rec, uint64(v))
	put(o.db, keyChannelFeerate, rec)
}

// HostFeerate reads the record stored under key "HostFeerate".
// If no record has been stored, HostFeerate returns
// the zero value.
func (o *Config) HostFeerate() int64 {
	rec := get(o.db, keyHostFeerate)
	if rec == nil {
		return 0
	}
	return int64(binary.BigEndian.Uint64(rec))
}

// PutHostFeerate stores v as a record under the key "HostFeerate".
func (o *Config) PutHostFeerate(v int64) {
	rec := make([]byte, 8)
	binary.BigEndian.PutUint64(rec, uint64(v))
	put(o.db, keyHostFeerate, rec)
}

// KeepAlive reads the record stored under key "KeepAlive".
// If no record has been stored, KeepAlive returns
// the zero value.
func (o *Config) KeepAlive() bool {
	rec := get(o.db, keyKeepAlive)
	return len(rec) > 0 && rec[0] != 0
}

// PutKeepAlive stores v as a record under the key "KeepAlive".
func (o *Config) PutKeepAlive(v bool) {
	rec := make([]byte, 1)
	if v {
		rec[0] = 1
	}
	put(o.db, keyKeepAlive, rec)
}

// MapOfFsmChannel is a bucket with arbitrary keys,
// holding records of type *fsm.Channel.
type MapOfFsmChannel struct {
	db *bolt.Bucket
}

// Bucket returns o's underlying *bolt.Bucket object.
// This can be useful to access low-level database functions
// or other features not exposed by this generated code.
//
// Note, if o's transaction is read-only and the underlying
// bucket has not previously been created in a writable
// transaction, Bucket returns nil.
func (o *MapOfFsmChannel) Bucket() *bolt.Bucket {
	return o.db
}

// Get reads the record stored in o under the given key.
//
// If no record has been stored, it returns
// a pointer to
// the zero value.
func (o *MapOfFsmChannel) Get(key []byte) *fsm.Channel {
	rec := get(o.db, key)
	v := new(fsm.Channel)
	if rec == nil {
		return v
	}
	err := json.Unmarshal(rec, json.Unmarshaler(v))
	if err != nil {
		panic(err)
	}
	return v
}

// GetByString is equivalent to o.Get([]byte(key)).
func (o *MapOfFsmChannel) GetByString(key string) *fsm.Channel {
	return o.Get([]byte(key))
}

// Put stores v in o as a record under the given key.
func (o *MapOfFsmChannel) Put(key []byte, v *fsm.Channel) {
	rec, err := json.Marshal(json.Marshaler(v))
	if err != nil {
		panic(err)
	}
	put(o.db, key, rec)
}

// PutByString is equivalent to o.Put([]byte(key), v).
func (o *MapOfFsmChannel) PutByString(key string, v *fsm.Channel) {
	o.Put([]byte(key), v)
}

// SeqOfUpdateUpdate is a bucket with sequential numeric keys,
// holding records of type *update.Update.
type SeqOfUpdateUpdate struct {
	db *bolt.Bucket
}

// Bucket returns o's underlying *bolt.Bucket object.
// This can be useful to access low-level database functions
// or other features not exposed by this generated code.
//
// Note, if o's transaction is read-only and the underlying
// bucket has not previously been created in a writable
// transaction, Bucket returns nil.
func (o *SeqOfUpdateUpdate) Bucket() *bolt.Bucket {
	return o.db
}

// Get reads the record stored in o under sequence number n.
//
// If no record has been stored, it returns
// a pointer to
// the zero value.
func (o *SeqOfUpdateUpdate) Get(n uint64) *update.Update {
	key := make([]byte, 8)
	binary.BigEndian.PutUint64(key, n)
	rec := get(o.db, key)
	v := new(update.Update)
	if rec == nil {
		return v
	}
	err := json.Unmarshal(rec, json.Unmarshaler(v))
	if err != nil {
		panic(err)
	}
	return v
}

// Add stores v in o under a new sequence number.
// It writes the new sequence number to *np
// before marshaling v. It is okay for
// np to point to a field inside v, to store
// the sequence number in the new record.
func (o *SeqOfUpdateUpdate) Add(v *update.Update, np *uint64) {
	n, err := o.db.NextSequence()
	if err != nil {
		panic(err)
	}
	*np = n
	o.Put(n, v)
}

// Put stores v in o as a record under sequence number n.
func (o *SeqOfUpdateUpdate) Put(n uint64, v *update.Update) {
	key := make([]byte, 8)
	binary.BigEndian.PutUint64(key, n)
	rec, err := json.Marshal(json.Marshaler(v))
	if err != nil {
		panic(err)
	}
	put(o.db, key, rec)
}

var (
	keyAgent            = []byte("Agent")
	keyChannelFeerate   = []byte("ChannelFeerate")
	keyChannels         = []byte("Channels")
	keyConfig           = []byte("Config")
	keyEncryptedSeed    = []byte("EncryptedSeed")
	keyFinalityDelayMin = []byte("FinalityDelayMin")
	keyHorizonURL       = []byte("HorizonURL")
	keyHostFeerate      = []byte("HostFeerate")
	keyKeepAlive        = []byte("KeepAlive")
	keyMaxRoundDurMin   = []byte("MaxRoundDurMin")
	keyNextKeypathIndex = []byte("NextKeypathIndex")
	keyPrimaryAcct      = []byte("PrimaryAcct")
	keyPwHash           = []byte("PwHash")
	keyPwType           = []byte("PwType")
	keyReady            = []byte("Ready")
	keyUpdates          = []byte("Updates")
	keyUsername         = []byte("Username")
	keyWallet           = []byte("Wallet")
)

type db interface {
	Writable() bool
	CreateBucketIfNotExists([]byte) (*bolt.Bucket, error)
	Bucket([]byte) *bolt.Bucket
}

func bucket(db db, key []byte) *bolt.Bucket {
	if bu, ok := db.(*bolt.Bucket); ok && bu == nil {
		return nil // can happen in read-only txs
	}
	if !db.Writable() {
		return db.Bucket(key)
	}
	b, err := db.CreateBucketIfNotExists(key)
	if err != nil {
		panic(err)
	}
	return b
}

func get(b *bolt.Bucket, key []byte) []byte {
	if b == nil {
		return nil
	}
	return b.Get(key)
}

func put(b *bolt.Bucket, key, value []byte) {
	err := b.Put(key, value)
	if err != nil {
		panic(err)
	}
}
